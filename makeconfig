#!/bin/sh -

[ -z "${WANT_ASSERTS}" ] && WANT_ASSERTS=0
[ -z "${WANT_NOALLOCA}" ] && WANT_NOALLOCA=0
[ -z "${WANT_NOGETOPT}" ] && WANT_NOGETOPT=0

if [ -z "${CONFIG}" ]; then
	[ -f ./user.conf ] && . ./user.conf
else
	case ${CONFIG} in
	MINIMAL)
		WANT_JUNK=0 WANT_SCORE=0 WANT_SOCKETS=0
		;;
	NETLESS)
		WANT_SOCKETS=0
		;;
	NETSEND)
		WANT_JUNK=0 WANT_SCORE=0 WANT_IMAP=0 WANT_POP3=0
		;;
	CUSTOM)
		;;
	*)
		echo >&2 "Unknown CONFIG= setting: ${CONFIG}"
		echo >&2 'Possible values: MINIMAL, NETLESS, NETSEND, CUSTOM'
		exit 1
	esac
fi

wantfeat() {
	eval i=\$WANT_${1}
	[ "${i}" != "0" ]
}
nwantfeat() {
	eval i=\$WANT_${1}
	[ "${i}" = "0" ]
}

if nwantfeat SOCKETS; then
	WANT_IPV6=0 WANT_SSL=0
	WANT_IMAP=0 WANT_GSSAPI=0 WANT_POP3=0 WANT_SMTP=0
fi
if nwantfeat IMAP && nwantfeat POP3 && nwantfeat SMTP; then
	WANT_SOCKETS=0 WANT_IPV6=0 WANT_SSL=0
fi
if nwantfeat IMAP; then
	WANT_GSSAPI=0
fi
# If we don't need MD5 except for producing boundary and message-id strings,
# leave it off, plain old srand(3) should be enough for that purpose.
if nwantfeat SOCKETS && nwantfeat JUNK; then
	WANT_MD5=0
elif wantfeat JUNK; then
	WANT_MD5=1
fi

##  --  >8  --  8<  --  ##

tmp=___build$$
tmp2=___tmp1$$
tmp3=___tmp2$$
out=config.h
log=config.log
lib=config.lib
inc=config.inc
makefile=config.mk

make="${MAKE-make}"

exec 5>&2 > ${log} 2>&1

rm -f ${out} ${lib} ${inc}
echo "\
/*
 * Auto-generated by ${0}.
 * Changes are lost when ${0} is run again.
 */
" > ${out}
: > ${lib}
: > ${inc}
cat > ${makefile} << \!
.SUFFIXES: .o .c .x .y
.c.o:
	$(CC) $(CFLAGS) $(INCS) -c $<

.c.x:
	$(CC) $(CFLAGS) $(INCS) -E $< >$@

.c:
	$(CC) $(CFLAGS) $(INCS) $(LDFLAGS) $< $(LIBS) -o $@

.y: ;

!

# (No function since some shells loose non-exported variables in traps)
trap "rm -f ${out} ${lib} ${inc} ${makefile}; exit" 1 2 15
trap "rm -rf ${tmp}.*; rm -f ${tmp} ${tmp2}* ${tmp3}* ${makefile}" 0

msg() {
	fmt=$1

	shift
	printf "*** ${fmt}\\n" "${@}"
	printf "${fmt}" "${@}" >&5
}

_check_preface() {
	variable=$1 topic=$2 define=$3

	echo '**********'
	msg "checking ${topic} ... "
	echo "/* checked ${topic} */" >> ${out}
	rm -f ${tmp} ${tmp}.o
	echo '*** test program is'
	tee ${tmp}.c
	#echo '*** the preprocessor generates'
	#${make} -f ${makefile} ${tmp}.x
	#cat ${tmp}.x
	echo '*** results are'
}

compile_check() {
	variable=$1 topic=$2 define=$3

	_check_preface "${variable}" "${topic}" "${define}"

	if ${make} -f ${makefile} INCS="${INCS}" ./${tmp}.o &&
			[ -f ./${tmp}.o ]; then
		msg "okay\\n"
		echo "${define}" >> ${out}
		eval have_${variable}=yes
		return 0
	else
		echo "/* ${define} */" >> ${out}
		msg "no\\n"
		eval unset have_${variable}
		return 1
	fi
}

_link_mayrun() {
	run=$1 variable=$2 topic=$3 define=$4 libs=$5 incs=$6

	_check_preface "${variable}" "${topic}" "${define}"

	if ${make} -f ${makefile} INCS="${INCS} ${incs}" \
				LIBS="${LIBS} ${libs}" ./${tmp} &&
			[ -f ./${tmp} ] &&
			{ [ ${run} -eq 0 ] || ./${tmp}; }; then
		msg "okay\\n"
		echo "${define}" >> ${out}
		LIBS="${LIBS} ${libs}"
		echo "${libs}" >> ${lib}
		INCS="${INCS} ${incs}"
		echo "${incs}" >> ${inc}
		eval have_${variable}=yes
		return 0
	else
		msg "no\\n"
		echo "/* ${define} */" >> ${out}
		eval unset have_${variable}
		return 1
	fi
}

link_check() {
	_link_mayrun 0 "${1}" "${2}" "${3}" "${4}" "${5}"
}

run_check() {
	_link_mayrun 1 "${1}" "${2}" "${3}" "${4}" "${5}"
}

# Build a basic set of INCS and LIBS according to user environment.
# On pkgsrc(7) systems automatically add /usr/pkg/*
if [ -n "${C_INCLUDE_PATH}" ]; then
	i=${IFS}
	IFS=:
	set -- ${C_INCLUDE_PATH}
	IFS=${i}
	for i
	do
		[ "${i}" = '/usr/pkg/include' ] && continue
		INCS="${INCS} -I${i}"
	done
fi
[ -d /usr/pkg/include ] && INCS="${INCS} -I/usr/pkg/include"
echo "${INCS}" >> ${inc}

if [ -n "${LD_LIBRARY_PATH}" ]; then
	i=${IFS}
	IFS=:
	set -- ${LD_LIBRARY_PATH}
	IFS=${i}
	for i
	do
		[ "${i}" = '/usr/pkg/lib' ] && continue
		LIBS="${LIBS} -L${i}"
	done
fi
[ -d /usr/pkg/lib ] && LIBS="${LIBS} -L/usr/pkg/lib"
echo "${LIBS}" >> ${lib}

##

link_check hello 'if a hello world program can be built' <<\! || { \
	echo >&5 'This oooops is most certainly not related to me.'; \
	echo >&5 "Read the file ${log} and check your compiler environment."; \
	rm ${out}; exit 1; \
}
#include <stdio.h>

int main(int argc, char *argv[])
{
	(void)argc;
	(void)argv;
	puts("hello world");
	return 0;
}
!

compile_check ssize_t 'for ssize_t' '#define HAVE_SSIZE_T' << \!
#include <sys/types.h>
#include <unistd.h>
int main(void)
{
	ssize_t	i = 3;
	write(1, "foo", i);
	return 0;
}
!

link_check snprintf 'for snprintf()' '#define HAVE_SNPRINTF' << \!
#include <stdio.h>
int main(void)
{
	char	b[20];
	snprintf(b, sizeof b, "%s", "string");
	return 0;
}
!

link_check putc_unlocked 'for putc_unlocked()' '#define HAVE_PUTC_UNLOCKED' <<\!
#include <stdio.h>
int main(void)
{
	putc_unlocked('@', stdout);
	return 0;
}
!

link_check fchdir 'for fchdir()' '#define HAVE_FCHDIR' << \!
#include <unistd.h>
int main(void)
{
	fchdir(0);
	return 0;
}
!

link_check mmap 'for mmap()' '#define HAVE_MMAP' << \!
#include <sys/types.h>
#include <sys/mman.h>
int main(void)
{
	mmap(0, 0, 0, 0, 0, 0);
	return 0;
}
!

link_check mremap 'for mremap()' '#define HAVE_MREMAP' << \!
#include <sys/types.h>
#include <sys/mman.h>
int main(void)
{
	mremap(0, 0, 0, MREMAP_MAYMOVE);
	return 0;
}
!

cat > ${tmp2}.c << \!
#include <iconv.h>
int main(void)
{
	iconv_t	id;

	id = iconv_open("foo", "bar");
	return 0;
}
!

< ${tmp2}.c link_check iconv 'for iconv functionality' '#define HAVE_ICONV' ||
	< ${tmp2}.c link_check iconv 'for iconv functionality in libiconv' \
		'#define HAVE_ICONV' '-liconv'

link_check wctype 'for wctype functionality' '#define HAVE_WCTYPE_H' << \!
#include <wctype.h>
int main(void)
{
	iswprint(L'c');
	towupper(L'c');
	return 0;
}
!

link_check wcwidth 'for wcwidth() ' '#define HAVE_WCWIDTH' << \!
#include <wchar.h>
int main(void)
{
	wcwidth(L'c');
	return 0;
}
!

link_check mbtowc 'for mbtowc()' '#define HAVE_MBTOWC' << \!
#include <stdlib.h>
int main(void)
{
	wchar_t	wc;
	mbtowc(&wc, "x", 1);
	return 0;
}
!

link_check setlocale 'for setlocale()' '#define HAVE_SETLOCALE' << \!
#include <locale.h>
int main(void)
{
	setlocale(LC_ALL, "");
	return 0;
}
!

link_check nl_langinfo 'for nl_langinfo()' '#define HAVE_NL_LANGINFO' << \!
#include <langinfo.h>
int main(void)
{
	nl_langinfo(DAY_1);
	return 0;
}
!

link_check mkstemp 'for mkstemp()' '#define HAVE_MKSTEMP' << \!
#include <stdlib.h>
int main(void)
{
	mkstemp("x");
	return 0;
}
!

link_check fpathconf 'for fpathconf()' '#define HAVE_FPATHCONF' << \!
#include <unistd.h>
int main(void)
{
	fpathconf(0, _PC_PATH_MAX);
	return 0;
}
!

link_check wordexp 'for wordexp()' '#define HAVE_WORDEXP' << \!
#include <wordexp.h>
int main(void)
{
	wordexp((char *)0, (wordexp_t *)0, 0);
	return 0;
}
!

##

if wantfeat ASSERTS; then
	echo '#define HAVE_ASSERTS' >> ${out}
fi

if nwantfeat NOALLOCA; then
	# Due to NetBSD PR lib/47120 it seems best not to use non-cc-builtin
	# versions of alloca(3) since modern compilers just can't be trusted
	# not to overoptimize and silently break some code
	link_check alloca 'for __builtin_alloca()' \
		'#define HAVE_ALLOCA __builtin_alloca' << \!
int main(void)
{
	void *vp = __builtin_alloca(1);
	return (!! vp);
}
!
fi

if nwantfeat NOGETOPT; then
	link_check getopt 'for getopt()' '#define HAVE_GETOPT' << \!
#include <unistd.h>
int main(int argc, char **argv)
{
#if defined __GLIBC__ || defined __linux__
	Argument and option reordering is not a desired feature.
#else
	getopt(argc, argv, "oPt");
#endif
	return (((long)optarg + optind) & 0x7F);
}
!
fi

##

if wantfeat SOCKETS; then
	compile_check arpa_inet_h 'for <arpa/inet.h>' \
		'#define HAVE_ARPA_INET_H' << \!
#include "config.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
!

	cat > ${tmp2}.c << \!
#include "config.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif

int main(void)
{
	struct sockaddr	s;
	socket(AF_INET, SOCK_STREAM, 0);
	connect(0, &s, 0);
	gethostbyname("foo");
	return 0;
}
!

	WANT_SOCKETS=1
	< ${tmp2}.c link_check sockets 'for sockets in libc' \
			'#define HAVE_SOCKETS' ||
		< ${tmp2}.c link_check sockets 'for sockets in libnsl' \
			'#define HAVE_SOCKETS' '-lnsl' ||
		< ${tmp2}.c link_check sockets \
			'for sockets in libsocket and libnsl' \
			'#define HAVE_SOCKETS' '-lsocket -lnsl' ||
		WANT_SOCKETS=0

	# XXX Shouldn't it be a hard error if there is no socket support, then?
	[ ${WANT_SOCKETS} -eq 1 ] ||
		WANT_IPV6=0 WANT_SSL=0 \
		WANT_IMAP=0 WANT_GSSAPI=0 WANT_POP3=0 WANT_SMTP=0
else
	echo '/* WANT_SOCKETS=0 */' >> ${out}
fi # wantfeat SOCKETS

if wantfeat IPV6; then
	link_check ipv6 'for IPv6 functionality' '#define USE_IPV6' << \!
#include "config.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#ifdef HAVE_ARPA_INET_H
#include <arpa/inet.h>
#endif

int main(void)
{
	struct addrinfo	a, *ap;
	getaddrinfo("foo", "0", &a, &ap);
	return 0;
}
!
else
	echo '/* WANT_IPV6=0 */' >> ${out}
fi # wantfeat IPV6

if wantfeat IMAP; then
	echo "#define USE_IMAP" >> ${out}
else
	echo '/* WANT_IMAP=0 */' >> ${out}
fi

if wantfeat POP3; then
	echo "#define USE_POP3" >> ${out}
else
	echo '/* WANT_POP3=0 */' >> ${out}
fi

if wantfeat SMTP; then
	echo "#define USE_SMTP" >> ${out}
else
	echo '/* WANT_SMTP=0 */' >> ${out}
fi

if wantfeat SSL; then
	link_check openssl 'for sufficiently recent OpenSSL' \
		'#define USE_SSL
		#define USE_OPENSSL' '-lssl -lcrypto' << \!
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>
#include <openssl/x509.h>
#include <openssl/rand.h>

int main(void)
{
	SSLv23_client_method();
	PEM_read_PrivateKey(0, 0, 0, 0);
	return 0;
}
!

	if [ "${have_openssl}" = 'yes' ]; then
		compile_check stack_of 'for STACK_OF()' \
			'#define HAVE_STACK_OF' << \!
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>
#include <openssl/x509.h>
#include <openssl/rand.h>

int main(void)
{
	STACK_OF(GENERAL_NAME)	*gens = NULL;
	printf("%p", gens);	/* to make it used */
	SSLv23_client_method();
	PEM_read_PrivateKey(0, 0, 0, 0);
	return 0;
}
!
	fi

else
	echo '/* WANT_SSL=0 */' >> ${out}
fi # wantfeat SSL

if wantfeat GSSAPI; then
	cat > ${tmp2}.c << \!
#include <gssapi/gssapi.h>

int main(void)
{
	gss_import_name(0, 0, GSS_C_NT_HOSTBASED_SERVICE, 0);
	gss_init_sec_context(0,0,0,0,0,0,0,0,0,0,0,0,0);
	return 0;
}
!
	sed -e '1s/gssapi\///' < ${tmp2}.c > ${tmp3}.c

	< ${tmp3}.c link_check gssapi 'for GSSAPI in libgssapi' \
			'#define USE_GSSAPI
			#define	GSSAPI_REG_INCLUDE' \
			'-lgssapi' || \
		< ${tmp3}.c link_check gssapi \
			'for GSSAPI in libgssapi, DragonFly BSD-style' \
			'#define USE_GSSAPI
			#define	GSSAPI_REG_INCLUDE' \
			'-lgssapi' \
			'-I/usr/pkg/include/krb5' || \
		< ${tmp2}.c link_check gssapi 'for GSSAPI in libgssapi_krb5' \
			'#define USE_GSSAPI' \
			'-lgssapi_krb5' || \
		< ${tmp3}.c link_check gssapi \
			'for GSSAPI in libgssapi, OpenBSD-style' \
			'#define USE_GSSAPI
			#define	GSSAPI_REG_INCLUDE' \
			'-lgssapi -lkrb5 -lcrypto' \
			'-I/usr/include/kerberosV' || \
		< ${tmp2}.c link_check gssapi 'for GSSAPI in libgss' \
			'#define USE_GSSAPI' \
			'-lgss' || \
		link_check gssapi 'for GSSAPI in libgssapi_krb5, old-style' \
			'#define USE_GSSAPI
			#define GSSAPI_OLD_STYLE' \
			'-lgssapi_krb5' << \!
#include <gssapi/gssapi.h>
#include <gssapi/gssapi_generic.h>

int main(void)
{
	gss_import_name(0, 0, gss_nt_service_name, 0);
	gss_init_sec_context(0,0,0,0,0,0,0,0,0,0,0,0,0);
	return 0;
}
!

else
	echo '/* WANT_GSSAPI=0 */' >> ${out}
fi # wantfeat GSSAPI

if wantfeat IDNA; then
	link_check idna 'for GNU Libidn' '#define USE_IDNA' '-lidn' << \!
#include <idna.h>
#include <stringprep.h>
#include <tld.h>

int main(void)
{
	char *utf8, *idna_ascii;
	uint32_t *idna_uni;
	size_t sz;
	utf8 = stringprep_locale_to_utf8("does.this.work");
	if (idna_to_ascii_8z(utf8, &idna_ascii, IDNA_USE_STD3_ASCII_RULES)
			!= IDNA_SUCCESS)
		return (1);
	if (idna_to_unicode_8z4z(idna_ascii, &idna_uni, 0) != IDNA_SUCCESS)
		return (1 + (unsigned char)idna_strerror(0)[0]);
	if (tld_check_4z(idna_uni, &sz, NULL) != TLD_SUCCESS)
		return (2 + (unsigned char)tld_strerror(0)[0]);
	return (0);
}
!

else
	echo '/* WANT_IDNA=0 */' >> ${out}
fi # wantfeat IDNA

if wantfeat JUNK; then
	echo "#define USE_JUNK" >> ${out}
else
	echo '/* WANT_JUNK=0 */' >> ${out}
fi

if wantfeat SCORE; then
	echo "#define USE_SCORE" >> ${out}
else
	echo '/* WANT_SCORE=0 */' >> ${out}
fi

if wantfeat DOCSTRINGS; then
	echo "#define USE_DOCSTRINGS" >> ${out}
else
	echo '/* WANT_DOCSTRINGS=0 */' >> ${out}
fi

if wantfeat MD5; then
	echo "#define USE_MD5" >> ${out}
else
	echo '/* WANT_MD5=0 */' >> ${out}
fi

# Since we cat(1) the content of those to cc/"ld", convert them to single line
squeeze_em() {
	< "${1}" > "${2}" awk \
	'BEGIN {ORS = " "} /^[^#]/ {print} {next} END {ORS = ""; print "\n"}'
}
rm -f "${tmp}"
squeeze_em "${inc}" "${tmp}"
mv "${tmp}" "${inc}"
squeeze_em "${lib}" "${tmp}"
mv "${tmp}" "${lib}"

# Finished!
cat > ${tmp2}.c << \!
#include "config.h"
#ifdef HAVE_NL_LANGINFO
#include <langinfo.h>
#endif
:
:The following optional features are enabled:
#ifdef HAVE_ICONV
: + Character set conversion using iconv()
#endif
#ifdef HAVE_SETLOCALE
: + Locale support: Printable characters depend on the environment
# if defined HAVE_MBTOWC && defined HAVE_WCTYPE_H
: + Multibyte character support
# endif
# if defined HAVE_NL_LANGINFO && defined CODESET
: + Automatic detection of terminal character set
# endif
#endif
#ifdef HAVE_SOCKETS
: + Network support
#endif
#ifdef USE_IPV6
: + Support for Internet Protocol v6 (IPv6)
#endif
#ifdef USE_OPENSSL
: + S/MIME and SSL/TLS using OpenSSL
#endif
#ifdef USE_IMAP
: + IMAP protocol
#endif
#ifdef USE_GSSAPI
: + IMAP GSSAPI authentication
#endif
#ifdef USE_POP3
: + POP3 protocol
#endif
#ifdef USE_SMTP
: + SMTP protocol
#endif
#ifdef USE_JUNK
: + Junk-mail management (Bayesian filtering)
#endif
#ifdef USE_SCORE
: + Message scoring (score/kill/unkill mechanism)
#endif
#ifdef USE_MD5
: + The MD5 message digest
#endif
#ifdef USE_IDNA
: + IDNA (internationalized domain names for applications) support
#endif
:
:The following optional features are disabled:
#ifndef	HAVE_ICONV
: - Character set conversion using iconv()
#endif
#ifndef	HAVE_SETLOCALE
: - Locale support: Only ASCII characters are recognized
#endif
#if ! defined HAVE_SETLOCALE || ! defined HAVE_MBTOWC || !defined HAVE_WCTYPE_H
: - Multibyte character support
#endif
#if ! defined HAVE_SETLOCALE || ! defined HAVE_NL_LANGINFO || ! defined CODESET
: - Automatic detection of terminal character set
#endif
#ifndef	HAVE_SOCKETS
: - Network support
#endif
#ifndef	USE_IPV6
: - Support for Internet Protocol v6 (IPv6)
#endif
#if ! defined USE_SSL
: - SSL/TLS (network transport authentication and encryption)
#endif
#ifndef USE_IMAP
: - IMAP protocol
#endif
#ifndef	USE_GSSAPI
: - IMAP GSSAPI authentication
#endif
#ifndef USE_POP3
: - POP3 protocol
#endif
#ifndef USE_SMTP
: - SMTP protocol
#endif
#ifndef USE_JUNK
: - Junk-mail management (Bayesian filtering)
#endif
#ifndef USE_SCORE
: - Message scoring (score/kill/unkill mechanism)
#endif
#ifndef USE_MD5
: - The MD5 message digest
#endif
#ifndef USE_IDNA
: - IDNA (internationalized domain names for applications) support
#endif
:
:Remarks:
#ifndef	HAVE_SNPRINTF
: * The function snprintf() could not be found. mailx will be compiled to use
: sprintf() instead. This might overflow buffers if input values are larger
: than expected. Use the resulting binary with care or update your system
: environment and start the configuration process again.
#endif
#ifndef	HAVE_FCHDIR
: * The function fchdir() could not be found. mailx will be compiled to use
: chdir() instead. This is not a problem unless the current working
: directory of mailx is moved while the IMAP cache is used.
#endif
#ifndef HAVE_GETOPT
: * A (usable) getopt() functionality could not be found.
: A builtin version is used instead.
#endif
#ifdef HAVE_ASSERTS
: * WANT_ASSERTS is enabled, the program binary will contain code assertions.
: There are also additional commands available, like "core".
: Such a binary is not meant to be used by end-users, but only for
: development purposes.  Thanks!
#endif
:
!

${make} -f ${makefile} ${tmp2}.x
< ${tmp2}.x >&5 sed '/^[^:]/d; /^$/d; s/^://'

exit 0
